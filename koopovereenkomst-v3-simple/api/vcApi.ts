/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * VC API
 * This is an Experimental Open API Specification for the [VC Data Model](https://www.w3.org/TR/vc-data-model/).
 *
 * OpenAPI spec version: 0.0.2-unstable
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * A JSON-LD Verifiable Credential without a proof.
 * @export
 * @interface Credential
 */
export interface Credential {
    /**
     * The JSON-LD context of the credential.
     * @type {Array<string>}
     * @memberof Credential
     */
    context?: Array<string>;
    /**
     * The ID of the credential.
     * @type {string}
     * @memberof Credential
     */
    id?: string;
    /**
     * The JSON-LD type of the credential.
     * @type {Array<string>}
     * @memberof Credential
     */
    type?: Array<string>;
    /**
     * 
     * @type {Issuer}
     * @memberof Credential
     */
    issuer?: Issuer;
    /**
     * The issuanceDate
     * @type {string}
     * @memberof Credential
     */
    issuanceDate?: string;
    /**
     * The expirationDate
     * @type {string}
     * @memberof Credential
     */
    expirationDate?: string;
    /**
     * The subject
     * @type {any}
     * @memberof Credential
     */
    credentialSubject?: any;
}
/**
 * Options for specifying how the derived credential is created.
 * @export
 * @interface DeriveCredentialOptions
 */
export interface DeriveCredentialOptions {
    /**
     * An encoded nonce provided by the holder of the credential to be included into the LinkedDataProof.
     * @type {string}
     * @memberof DeriveCredentialOptions
     */
    nonce?: string;
}
/**
 * 
 * @export
 * @interface DeriveCredentialRequest
 */
export interface DeriveCredentialRequest {
    /**
     * 
     * @type {VerifiableCredential}
     * @memberof DeriveCredentialRequest
     */
    verifiableCredential?: VerifiableCredential;
    /**
     * A JSON-LD frame used for selective disclosure.
     * @type {any}
     * @memberof DeriveCredentialRequest
     */
    frame?: any;
    /**
     * 
     * @type {DeriveCredentialOptions}
     * @memberof DeriveCredentialRequest
     */
    options?: DeriveCredentialOptions;
}
/**
 * 
 * @export
 * @interface DeriveCredentialResponse
 */
export interface DeriveCredentialResponse {
}
/**
 * Options for specifying how the LinkedDataProof is created.
 * @export
 * @interface IssueCredentialOptions
 */
export interface IssueCredentialOptions {
    /**
     * The URI of the verificationMethod used for the proof. Default assertionMethod URI.
     * @type {string}
     * @memberof IssueCredentialOptions
     */
    verificationMethod?: string;
    /**
     * The purpose of the proof. Default 'assertionMethod'.
     * @type {string}
     * @memberof IssueCredentialOptions
     */
    proofPurpose?: string;
    /**
     * The date and time of the proof (with a maximum accuracy in seconds). Default current system time.
     * @type {string}
     * @memberof IssueCredentialOptions
     */
    created?: string;
    /**
     * A challenge provided by the requesting party of the proof. For example 6e62f66e-67de-11eb-b490-ef3eeefa55f2
     * @type {string}
     * @memberof IssueCredentialOptions
     */
    challenge?: string;
    /**
     * The intended domain of validity for the proof. For example website.example
     * @type {string}
     * @memberof IssueCredentialOptions
     */
    domain?: string;
    /**
     * 
     * @type {IssueCredentialOptionsCredentialStatus}
     * @memberof IssueCredentialOptions
     */
    credentialStatus?: IssueCredentialOptionsCredentialStatus;
}
/**
 * The method of credential status to issue the credential including. If omitted credential status will be included.
 * @export
 * @interface IssueCredentialOptionsCredentialStatus
 */
export interface IssueCredentialOptionsCredentialStatus {
    /**
     * The type of credential status to issue the credential with
     * @type {string}
     * @memberof IssueCredentialOptionsCredentialStatus
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface IssueCredentialRequest
 */
export interface IssueCredentialRequest {
    /**
     * 
     * @type {Credential}
     * @memberof IssueCredentialRequest
     */
    credential?: Credential;
    /**
     * 
     * @type {IssueCredentialOptions}
     * @memberof IssueCredentialRequest
     */
    options?: IssueCredentialOptions;
}
/**
 * 
 * @export
 * @interface IssueCredentialResponse
 */
export interface IssueCredentialResponse {
}
/**
 * A JSON-LD Verifiable Credential Issuer.
 * @export
 * @interface Issuer
 */
export interface Issuer {
}
/**
 * A JSON-LD Linked Data proof.
 * @export
 * @interface LinkedDataProof
 */
export interface LinkedDataProof {
    /**
     * Linked Data Signature Suite used to produce proof.
     * @type {string}
     * @memberof LinkedDataProof
     */
    type?: string;
    /**
     * Date the proof was created.
     * @type {string}
     * @memberof LinkedDataProof
     */
    created?: string;
    /**
     * Verification Method used to verify proof.
     * @type {string}
     * @memberof LinkedDataProof
     */
    verificationMethod?: string;
    /**
     * The purpose of the proof to be used with verificationMethod.
     * @type {string}
     * @memberof LinkedDataProof
     */
    proofPurpose?: string;
    /**
     * Detached JSON Web Signature
     * @type {string}
     * @memberof LinkedDataProof
     */
    jws?: string;
}
/**
 * Options for specifying how the LinkedDataProof is created.
 * @export
 * @interface PresentCredentialOptions
 */
export interface PresentCredentialOptions {
    /**
     * The URI of the verificationMethod used for the proof. Default assertionMethod URI.
     * @type {string}
     * @memberof PresentCredentialOptions
     */
    verificationMethod?: string;
    /**
     * The purpose of the proof. Default 'assertionMethod'.
     * @type {string}
     * @memberof PresentCredentialOptions
     */
    proofPurpose?: string;
    /**
     * The date and time of the proof (with a maximum accuracy in seconds). Default current system time.
     * @type {string}
     * @memberof PresentCredentialOptions
     */
    created?: string;
    /**
     * A challenge provided by the requesting party of the proof. For example 6e62f66e-67de-11eb-b490-ef3eeefa55f2
     * @type {string}
     * @memberof PresentCredentialOptions
     */
    challenge?: string;
    /**
     * The intended domain of validity for the proof. For example website.example
     * @type {string}
     * @memberof PresentCredentialOptions
     */
    domain?: string;
}
/**
 * A JSON-LD Verifiable Presentation without a proof.
 * @export
 * @interface Presentation
 */
export interface Presentation {
    /**
     * The JSON-LD context of the presentation.
     * @type {Array<string>}
     * @memberof Presentation
     */
    context?: Array<string>;
    /**
     * The ID of the presentation.
     * @type {string}
     * @memberof Presentation
     */
    id?: string;
    /**
     * The JSON-LD type of the presentation.
     * @type {Array<string>}
     * @memberof Presentation
     */
    type?: Array<string>;
    /**
     * The holder - will be ignored if no proof is present since there is no proof of authority over the credentials
     * @type {any}
     * @memberof Presentation
     */
    holder?: any;
    /**
     * The Verifiable Credentials
     * @type {Array<any>}
     * @memberof Presentation
     */
    verifiableCredential?: Array<any>;
}
/**
 * 
 * @export
 * @interface PresentationsVerifyBody
 */
export interface PresentationsVerifyBody {
}
/**
 * 
 * @export
 * @interface ProoflessVerifyPresentationRequest
 */
export interface ProoflessVerifyPresentationRequest {
    /**
     * 
     * @type {Presentation}
     * @memberof ProoflessVerifyPresentationRequest
     */
    presentation?: Presentation;
}
/**
 * 
 * @export
 * @interface ProvePresentationRequest
 */
export interface ProvePresentationRequest {
    /**
     * 
     * @type {Presentation}
     * @memberof ProvePresentationRequest
     */
    presentation?: Presentation;
    /**
     * 
     * @type {PresentCredentialOptions}
     * @memberof ProvePresentationRequest
     */
    options?: PresentCredentialOptions;
}
/**
 * 
 * @export
 * @interface ProvePresentationResponse
 */
export interface ProvePresentationResponse {
}
/**
 * Request for updating the status of an issued credential.
 * @export
 * @interface UpdateCredentialStatus
 */
export interface UpdateCredentialStatus {
    /**
     * 
     * @type {string}
     * @memberof UpdateCredentialStatus
     */
    credentialId?: string;
    /**
     * 
     * @type {Array<UpdateCredentialStatusCredentialStatus>}
     * @memberof UpdateCredentialStatus
     */
    credentialStatus?: Array<UpdateCredentialStatusCredentialStatus>;
}
/**
 * 
 * @export
 * @interface UpdateCredentialStatusCredentialStatus
 */
export interface UpdateCredentialStatusCredentialStatus {
    /**
     * 
     * @type {string}
     * @memberof UpdateCredentialStatusCredentialStatus
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCredentialStatusCredentialStatus
     */
    status?: string;
}
/**
 * A JSON-LD Verifiable Credential with a proof.
 * @export
 * @interface VerifiableCredential
 */
export interface VerifiableCredential extends Credential {
    /**
     * 
     * @type {LinkedDataProof}
     * @memberof VerifiableCredential
     */
    proof: LinkedDataProof;
}
/**
 * A JSON-LD Verifiable Presentation with a proof.
 * @export
 * @interface VerifiablePresentation
 */
export interface VerifiablePresentation extends Presentation {
    /**
     * 
     * @type {LinkedDataProof}
     * @memberof VerifiablePresentation
     */
    proof?: LinkedDataProof;
}
/**
 * Object summarizing a verification
 * @export
 * @interface VerificationResult
 */
export interface VerificationResult {
    /**
     * The checks performed
     * @type {Array<string>}
     * @memberof VerificationResult
     */
    checks?: Array<string>;
    /**
     * Warnings
     * @type {Array<string>}
     * @memberof VerificationResult
     */
    warnings?: Array<string>;
    /**
     * Errors
     * @type {Array<string>}
     * @memberof VerificationResult
     */
    errors?: Array<string>;
}
/**
 * 
 * @export
 * @interface VerifyCredentialRequest
 */
export interface VerifyCredentialRequest {
    /**
     * 
     * @type {VerifiableCredential}
     * @memberof VerifyCredentialRequest
     */
    verifiableCredential?: VerifiableCredential;
    /**
     * 
     * @type {VerifyOptions}
     * @memberof VerifyCredentialRequest
     */
    options?: VerifyOptions;
}
/**
 * 
 * @export
 * @interface VerifyCredentialResponse
 */
export interface VerifyCredentialResponse {
}
/**
 * Options for specifying how the LinkedDataProof is created.
 * @export
 * @interface VerifyOptions
 */
export interface VerifyOptions {
    /**
     * The URI of the verificationMethod used for the proof. Default assertionMethod URI.
     * @type {string}
     * @memberof VerifyOptions
     */
    verificationMethod?: string;
    /**
     * The purpose of the proof. Default 'assertionMethod'.
     * @type {string}
     * @memberof VerifyOptions
     */
    proofPurpose?: string;
    /**
     * The date and time of the proof (with a maximum accuracy in seconds). Default current system time.
     * @type {string}
     * @memberof VerifyOptions
     */
    created?: string;
    /**
     * A challenge provided by the requesting party of the proof. For example 6e62f66e-67de-11eb-b490-ef3eeefa55f2
     * @type {string}
     * @memberof VerifyOptions
     */
    challenge?: string;
    /**
     * The intended domain of validity for the proof. For example website.example
     * @type {string}
     * @memberof VerifyOptions
     */
    domain?: string;
}
/**
 * 
 * @export
 * @interface VerifyPresentationRequest
 */
export interface VerifyPresentationRequest {
    /**
     * 
     * @type {VerifiablePresentation}
     * @memberof VerifyPresentationRequest
     */
    verifiablePresentation?: VerifiablePresentation;
    /**
     * 
     * @type {VerifyOptions}
     * @memberof VerifyPresentationRequest
     */
    options?: VerifyOptions;
}
/**
 * 
 * @export
 * @interface VerifyPresentationResponse
 */
export interface VerifyPresentationResponse {
}
/**
 * HolderApi - fetch parameter creator
 * @export
 */
export const HolderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Derives a credential and returns it in the response body.
         * @summary Derives a credential and returns it in the response body.
         * @param {DeriveCredentialRequest} [body] Parameters for deriving the credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deriveCredential(body?: DeriveCredentialRequest, options: any = {}): FetchArgs {
            const localVarPath = `/credentials/derive`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeriveCredentialRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Proves a presentation and returns it in the response body.
         * @summary Proves a presentation and returns it in the response body.
         * @param {ProvePresentationRequest} [body] Parameters for proving the presentation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provePresentation(body?: ProvePresentationRequest, options: any = {}): FetchArgs {
            const localVarPath = `/presentations/prove`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProvePresentationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HolderApi - functional programming interface
 * @export
 */
export const HolderApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Derives a credential and returns it in the response body.
         * @summary Derives a credential and returns it in the response body.
         * @param {DeriveCredentialRequest} [body] Parameters for deriving the credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deriveCredential(body?: DeriveCredentialRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeriveCredentialResponse> {
            const localVarFetchArgs = HolderApiFetchParamCreator(configuration).deriveCredential(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Proves a presentation and returns it in the response body.
         * @summary Proves a presentation and returns it in the response body.
         * @param {ProvePresentationRequest} [body] Parameters for proving the presentation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provePresentation(body?: ProvePresentationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProvePresentationResponse> {
            const localVarFetchArgs = HolderApiFetchParamCreator(configuration).provePresentation(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HolderApi - factory interface
 * @export
 */
export const HolderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Derives a credential and returns it in the response body.
         * @summary Derives a credential and returns it in the response body.
         * @param {DeriveCredentialRequest} [body] Parameters for deriving the credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deriveCredential(body?: DeriveCredentialRequest, options?: any) {
            return HolderApiFp(configuration).deriveCredential(body, options)(fetch, basePath);
        },
        /**
         * Proves a presentation and returns it in the response body.
         * @summary Proves a presentation and returns it in the response body.
         * @param {ProvePresentationRequest} [body] Parameters for proving the presentation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provePresentation(body?: ProvePresentationRequest, options?: any) {
            return HolderApiFp(configuration).provePresentation(body, options)(fetch, basePath);
        },
    };
};

/**
 * HolderApi - object-oriented interface
 * @export
 * @class HolderApi
 * @extends {BaseAPI}
 */
export class HolderApi extends BaseAPI {
    /**
     * Derives a credential and returns it in the response body.
     * @summary Derives a credential and returns it in the response body.
     * @param {DeriveCredentialRequest} [body] Parameters for deriving the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolderApi
     */
    public deriveCredential(body?: DeriveCredentialRequest, options?: any) {
        return HolderApiFp(this.configuration).deriveCredential(body, options)(this.fetch, this.basePath);
    }

    /**
     * Proves a presentation and returns it in the response body.
     * @summary Proves a presentation and returns it in the response body.
     * @param {ProvePresentationRequest} [body] Parameters for proving the presentation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolderApi
     */
    public provePresentation(body?: ProvePresentationRequest, options?: any) {
        return HolderApiFp(this.configuration).provePresentation(body, options)(this.fetch, this.basePath);
    }

}
/**
 * IssuerApi - fetch parameter creator
 * @export
 */
export const IssuerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Issues a credential and returns it in the response body.
         * @summary Issues a credential and returns it in the response body.
         * @param {IssueCredentialRequest} [body] Parameters for issuing the credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCredential(body?: IssueCredentialRequest, options: any = {}): FetchArgs {
            const localVarPath = `/credentials/issue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IssueCredentialRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the status of an issued credential.
         * @summary Updates the status of an issued credential
         * @param {UpdateCredentialStatus} [body] Parameters for updating the status of the issued credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredentialStatus(body?: UpdateCredentialStatus, options: any = {}): FetchArgs {
            const localVarPath = `/credentials/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCredentialStatus" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssuerApi - functional programming interface
 * @export
 */
export const IssuerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Issues a credential and returns it in the response body.
         * @summary Issues a credential and returns it in the response body.
         * @param {IssueCredentialRequest} [body] Parameters for issuing the credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCredential(body?: IssueCredentialRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IssueCredentialResponse> {
            const localVarFetchArgs = IssuerApiFetchParamCreator(configuration).issueCredential(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the status of an issued credential.
         * @summary Updates the status of an issued credential
         * @param {UpdateCredentialStatus} [body] Parameters for updating the status of the issued credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredentialStatus(body?: UpdateCredentialStatus, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IssuerApiFetchParamCreator(configuration).updateCredentialStatus(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IssuerApi - factory interface
 * @export
 */
export const IssuerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Issues a credential and returns it in the response body.
         * @summary Issues a credential and returns it in the response body.
         * @param {IssueCredentialRequest} [body] Parameters for issuing the credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCredential(body?: IssueCredentialRequest, options?: any) {
            return IssuerApiFp(configuration).issueCredential(body, options)(fetch, basePath);
        },
        /**
         * Updates the status of an issued credential.
         * @summary Updates the status of an issued credential
         * @param {UpdateCredentialStatus} [body] Parameters for updating the status of the issued credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredentialStatus(body?: UpdateCredentialStatus, options?: any) {
            return IssuerApiFp(configuration).updateCredentialStatus(body, options)(fetch, basePath);
        },
    };
};

/**
 * IssuerApi - object-oriented interface
 * @export
 * @class IssuerApi
 * @extends {BaseAPI}
 */
export class IssuerApi extends BaseAPI {
    /**
     * Issues a credential and returns it in the response body.
     * @summary Issues a credential and returns it in the response body.
     * @param {IssueCredentialRequest} [body] Parameters for issuing the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuerApi
     */
    public issueCredential(body?: IssueCredentialRequest, options?: any) {
        return IssuerApiFp(this.configuration).issueCredential(body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the status of an issued credential.
     * @summary Updates the status of an issued credential
     * @param {UpdateCredentialStatus} [body] Parameters for updating the status of the issued credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuerApi
     */
    public updateCredentialStatus(body?: UpdateCredentialStatus, options?: any) {
        return IssuerApiFp(this.configuration).updateCredentialStatus(body, options)(this.fetch, this.basePath);
    }

}
/**
 * VerifierApi - fetch parameter creator
 * @export
 */
export const VerifierApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Verifies a verifiableCredential and returns a verificationResult in the response body.
         * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
         * @param {VerifyCredentialRequest} [body] Parameters for verifying a verifiableCredential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredential(body?: VerifyCredentialRequest, options: any = {}): FetchArgs {
            const localVarPath = `/credentials/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyCredentialRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies a verifiablePresentation and returns a verificationResult in the response body.  Given the possibility of denial of service, buffer overflow, or other style attacks, an implementation is permitted to rate limit or restrict requests against this API endpoint to those requests that contain only a single credential with a 413 or 429 error code as appropriate.
         * @summary Verifies a Presentation with or without proofs attached and returns a verificationResult in the response body.
         * @param {PresentationsVerifyBody} [body] Parameters for verifying a verifiablePresentation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyPresentation(body?: PresentationsVerifyBody, options: any = {}): FetchArgs {
            const localVarPath = `/presentations/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PresentationsVerifyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerifierApi - functional programming interface
 * @export
 */
export const VerifierApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Verifies a verifiableCredential and returns a verificationResult in the response body.
         * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
         * @param {VerifyCredentialRequest} [body] Parameters for verifying a verifiableCredential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredential(body?: VerifyCredentialRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerifyCredentialResponse> {
            const localVarFetchArgs = VerifierApiFetchParamCreator(configuration).verifyCredential(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Verifies a verifiablePresentation and returns a verificationResult in the response body.  Given the possibility of denial of service, buffer overflow, or other style attacks, an implementation is permitted to rate limit or restrict requests against this API endpoint to those requests that contain only a single credential with a 413 or 429 error code as appropriate.
         * @summary Verifies a Presentation with or without proofs attached and returns a verificationResult in the response body.
         * @param {PresentationsVerifyBody} [body] Parameters for verifying a verifiablePresentation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyPresentation(body?: PresentationsVerifyBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerifyPresentationResponse> {
            const localVarFetchArgs = VerifierApiFetchParamCreator(configuration).verifyPresentation(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VerifierApi - factory interface
 * @export
 */
export const VerifierApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Verifies a verifiableCredential and returns a verificationResult in the response body.
         * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
         * @param {VerifyCredentialRequest} [body] Parameters for verifying a verifiableCredential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredential(body?: VerifyCredentialRequest, options?: any) {
            return VerifierApiFp(configuration).verifyCredential(body, options)(fetch, basePath);
        },
        /**
         * Verifies a verifiablePresentation and returns a verificationResult in the response body.  Given the possibility of denial of service, buffer overflow, or other style attacks, an implementation is permitted to rate limit or restrict requests against this API endpoint to those requests that contain only a single credential with a 413 or 429 error code as appropriate.
         * @summary Verifies a Presentation with or without proofs attached and returns a verificationResult in the response body.
         * @param {PresentationsVerifyBody} [body] Parameters for verifying a verifiablePresentation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyPresentation(body?: PresentationsVerifyBody, options?: any) {
            return VerifierApiFp(configuration).verifyPresentation(body, options)(fetch, basePath);
        },
    };
};

/**
 * VerifierApi - object-oriented interface
 * @export
 * @class VerifierApi
 * @extends {BaseAPI}
 */
export class VerifierApi extends BaseAPI {
    /**
     * Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @param {VerifyCredentialRequest} [body] Parameters for verifying a verifiableCredential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifierApi
     */
    public verifyCredential(body?: VerifyCredentialRequest, options?: any) {
        return VerifierApiFp(this.configuration).verifyCredential(body, options)(this.fetch, this.basePath);
    }

    /**
     * Verifies a verifiablePresentation and returns a verificationResult in the response body.  Given the possibility of denial of service, buffer overflow, or other style attacks, an implementation is permitted to rate limit or restrict requests against this API endpoint to those requests that contain only a single credential with a 413 or 429 error code as appropriate.
     * @summary Verifies a Presentation with or without proofs attached and returns a verificationResult in the response body.
     * @param {PresentationsVerifyBody} [body] Parameters for verifying a verifiablePresentation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifierApi
     */
    public verifyPresentation(body?: PresentationsVerifyBody, options?: any) {
        return VerifierApiFp(this.configuration).verifyPresentation(body, options)(this.fetch, this.basePath);
    }

}
